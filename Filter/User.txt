Итак. Вы, наверняка, согласитесь, что файл - это именованная цепочка байтов, у которой есть начало и конец.
В С++ существует библиотека под названием fstream. С её помощью, можно осуществить следующие функции: 
	Cоздание файла. 
	Cоздание потока. 
	Открытие файла. 
	"Присоединение" файла к потоку. 
	Обмен с файлом с помощью потока. 
	"Отсоединение" потока от файла. 
	Закрытие файла. 
	Уничтожение файла. 
Примечание: Для корректной работы библиотеки fstream необходимо использовать using namespace std;
Библиотека fstream, как и библиотека iostream содержит три класса, предназначенных для ввода и вывода данных в файлы:
	ofstream - для вывода (записи) данных в файл. 
	ifstream - для ввода (чтения) данных из файла. 
	fstream - для чтения и для записи данных. 
Для каждого из этих трех классов предусмотрено четыре конструктора. Рассмотрим их:
fstream() - создает поток, не открывая файла;
fstream(
        const char* name,           // имя файла
        int omode,                  // режим открытия
        int = filebuf::openprot   // защита файла
       ) - создает поток, открывает файл и связывает его с потоком;

fstream(
        int f                       // дескриптор файла
       ) - создает поток и связывает его с уже открытым файлом

       fstream(
        int f,                      // дескриптор файла
        char *buf,                  // буфер
        int len                     // размер буфера
       ) - то же, что предыдущий конструктор, но потоку назначается буфер.

Среди вышеперечисленных параметров можно выделить параметр omode. Это набор флагов для открытия файла:
enum _Openmode {
        in = 0x01, // открыть только для чтения
        out = 0x02, // открыть только для записи
        ate = 0x04, // установить указатель на конец файла
        app = 0x08, // дописывать данные в конец файла
        trunc = 0x10, // усечь файл до нулевой длины
        _Nocreate = 0x40, // если файл не существует, ошибка открытия
        _Noreplace = 0x80, // если файл уже существует, ошибка открытия
        binary = 0x20  // открыть файл для двоичного обмена
};

Примечание: Для определения флага к нему необходимо добавить ios::. Например, ios::in.
Функции для работы с файлами.


void open(const char *fileName, int mode = знач_по_ум,int protection = знач_по_ум);
"Присоединяет" файловый поток к конкретному файлу. 
fileName - имя уже существующего или создаваемого заново файла. Это строка, которая задает полное или сокращенное имя файла в формате, определенном операционной системой. 
mode - режим открытия. 
protection - защита файла. 
Функция вызывается через объект любого из трех потоковых классов и записывает в него нуль в случае ошибки.


int close();
Функция очищает буфер потока, отсоединяет поток от файла и закрывает файл.
Примечание: Эта функция вызывается автоматически при завершении программы.
istream&amp; istream::read( unsigned char *buf, int len);
istream&amp; istream::read( signed char *buf, int len);
Производит чтение блока символов. 
len - максимальное число символов, которые должны быть извлечены из потока в буфер buf. 

ostream&amp; osteram::write( const unsigned char *buf, int n);
ostream&amp; osteram::write( const signed char *buf, int n);

Производит запись блока символов. 
n - число символов, считая ноль-символ, которые должны быть помещены в поток из буфера buf. 

int istream::get();
istream& istream::get( unsigned char&);
istream& istream::get( signed char&);
Извлекает один символ из потока. 

ostream& ostream::put( char);
Помещает один символ в поток. 

istream& istream::get( unsigned char *buf, int n, char c = '\n');
istream& istream::get( signed char *buf, int n, char c = '\n');
Извлекает строку из потока. 
Во всех вышеописанных функциях символы извлекаются и помещаются в буфер пока не будет найден символ-ограничитель, или не будет прочитано n символов, или не встретится конец файла. Ограничитель из потока не извлекается и в буфер не помещается. 

istream& istream::getline( unsigned char *buf, int n, char c = '\n');
istream& istream::getline( signed char *buf, int n, char c = '\n');
Данная функция выполняет то же, что и get, но ограничитель извлекается из потока (в буфер не заносится). 

istream& istream::ignore( int n = 1, int d = EOF);
Данная функция извлекает символы из потока, пока не встретится ограничитель d или пока не извлечет n символов. 

int istream::gcount();
Данная функция возвращает число символов, извлеченных последней функцией бесформатного ввода. 

int istream::peek();
Данная функция позволяет "взглянуть" на очередной символ входного потока - возвращает код следующего символа потока (или EOF, если поток пуст), но оставляет этот символ в потоке. При необходимости этот символ можно извлечь из потока с помощью других средств библиотеки. 
istream& istream::putback( char cc);
Данная функция не извлекает ничего из потока, а помещает в него символ cc, который становится текущим и будет следующим извлекаемым из потока символом. 
istream& istream::seekg( long pos);
Данная функция устанавливает позицию чтения из потока в положение, определяемое значением параметра. 

istream& istream::seekg( long off, ios::seek_dir dir);
Данная функция выполняет перемещение позиции чтения вдоль потока в направлении, опеределенном параметром dir, который принимает значение из перечисления enum seek_dir {beg, cur, end};. Относительная величина перемещения ( в байтах) определяется значением параметра long off. Если направление определено как beg, то смещение от начала потока; cur - от текущей позиции; end - от конца потока. 

ostream& ostream::seekp( long pos);
Данная функция устанавливает абсолютную позицию записи в поток. 

ostream& ostream::seekp( long off, ios::seek_dir dir);
Данная функция аналогична функции seekg(), но принадлежит классу ostream и выполняет относительное перемещение записи в поток. 

long istream::tellg();
Данная функция определяет текущую позицию чтения из потока. 

long ostream::tellp();
Данная функция определяет текущую позицию записи в поток. 
Ну, что ж теории, пожалуй достаточно - пора переходить к практике. В следующих разделах урока мы рассмотрим несколько примеров.
